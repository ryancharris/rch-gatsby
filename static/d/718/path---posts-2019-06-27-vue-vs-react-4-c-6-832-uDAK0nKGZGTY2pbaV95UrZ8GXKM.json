{"data":{"markdownRemark":{"html":"<p><em>Originally <a href=\"https://blog.logrocket.com/5-vue-tips-for-react-developers/\">published</a> on <a href=\"https://logrocket.com/\">LogRocket</a></em></p>\n<p>For frontend developers, JavaScript frameworks have become increasingly important due to how fundamentally they change the way we approach building our applications. While not everyone uses them professional, or at all, the development community sure loves to talk about them. Unfortunately, these discussions often devolve into a diatribe about Framework X being better than Framework Y, or Framework Z not being “real JavaScript.”</p>\n<p>As an engineer, I have always found it strange to think of one framework as “better” than another when they’re really all flavors of the same. Essentially, these tools are all trying to solve the same problems and improve the developer experience; they just take different approaches.</p>\n<p>The intent of those building these frameworks is to empower developers to make better applications by making it easier for them to:</p>\n<ol>\n<li>Build reusable UI components</li>\n<li>Manage application state</li>\n<li>Inject data</li>\n</ol>\n<p>Sometimes it can feel like there is a hot new framework every other day (looking at you, Svelte), but React and Vue have been two of the most popular in recent years. Both are widely used at scale and have large, active open source communities.</p>\n<p>As a React developer at Guru, I primarily work with React. However, I have recently been working with a local Vue meetup to coordinate the use of our office space for their events. Having not built anything with Vue in a while, I decided this would be the perfect opportunity to build something cool and re-familiarize myself, with the added benefit of comparing it to React.</p>\n<p>Before we go any further, I just want to say: this article is not intended to determine whether React or Vue is better than the other. Instead, I hope to examine both frameworks in a practical sense and see how they differ when it comes to solving common problems. Examining another framework can even inform us of how to better use our own.</p>\n<h3>Background</h3>\n<p>I recently bought a house and moved to a new neighborhood, so I no longer have access to the subway and must rely on the bus system to get to work. While having some time to read on my slightly longer commute can be nice, standing outside for a bus that never seems to come is not.</p>\n<p>This seemed like a problem for which I could build a solution using Vue. Even though I could easily check SEPTA’s website or Google Maps (more on this later), I wanted to create a simple app that would tell me how much time I had until the next bus so I could quickly check it and run out the door.</p>\n<p>Since there are more aspects to any given framework than can be covered in this article, we are going to focus on the difference I encountered while trying to achieve the goals of this small project:</p>\n<ul>\n<li>It must have two views: one for heading to work, the other for heading home</li>\n<li>It must show information for the two bus lines I use to commute</li>\n<li>It must show when the next bus is arriving at each station</li>\n</ul>\n<p><em>Side note: My local transit authority did not have a solid API, so I ultimately ended up having to rely on Google Maps. To prevent tons of API calls, I set up a timed job to hit the API and then write a JSON file to cloud storage. This JSON is the data the app uses to render.</em></p>\n<p>In the end, the application ended up looking like this:</p>\n<iframe src=\"https://codesandbox.io/embed/brew-bus-r8xkp?fontsize=14&module=%2Fsrc%2FApp.vue\" title=\"Brew Bus\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n<h3>Approach</h3>\n<p>As we discussed earlier, React and Vue both have similar goals but differ slightly in their approach. When I say approach, I am referring to the way in which you, the developer, go about building your components.</p>\n<p>Of the two frameworks, Vue takes a more template-like approach, not dissimilar from the markup and templating tools used with Model-View-Controller frameworks in other languages like Ruby, Elixir, and PHP.</p>\n<p>React, on the other hand, feels a bit more like HTML-in-JavaScript. Take a look at the two components below and see if you can figure out what’s happening.</p>\n<p>First, with React:</p>\n<pre><code>function Accordion() {\n  const [isAccordionOpen, toggleAccordion] = React.useState(false);\n\n  return (\n    &#x3C;div className=\"Accordion\">\n      &#x3C;h3>Accordion Header&#x3C;/h3>\n      &#x3C;button\n        onClick={() => {\n          toggleAccordion(!isAccordionOpen);\n        }}\n      >\n        Toggle Accordion\n      &#x3C;/button>\n      {isAccordionOpen &#x26;&#x26; &#x3C;p>Accordion content lives here...&#x3C;/p>}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Now, with Vue:</p>\n<pre><code>&#x3C;template>\n  &#x3C;div class=\"accordion\">\n    &#x3C;button @click=\"toggleAccordion\">Toggle Accordion&#x3C;/button>\n    &#x3C;p v-if=\"isAccordionOpen\">Accordion content lives here...&#x3C;/p>\n  &#x3C;/div>\n&#x3C;/template>\n\n&#x3C;script>\nexport default {\n  name: \"Accordion\",\n  data: function() {\n    return {\n      isAccordionOpen: false,\n    };\n  },\n  methods: {\n    toggleAccordion() {\n      this.isAccordionOpen = !this.isAccordionOpen;\n    },\n  },\n};\n&#x3C;/script>\n</code></pre>\n<p>One is not necessarily better than the other; they’re just different. And that’s what makes them so interesting!</p>\n<h3>React vs. Vue</h3>\n<p>Below, I’ve highlighted five tasks a developer commonly performs when building applications and created examples of how to achieve the desired outcome using either framework.</p>\n<h4>#1 Conditional Rendering</h4>\n<p>A common strategy developers use is called conditional rendering. Essentially, this is a fancy way of saying “if X, then Y.” This is often how we show or hide parts of our interface from the user.</p>\n<p>We can see an example of this in <strong>App.vue</strong> within the <code>&#x3C;template></code> tags. Two of our components (<code>&#x3C;Work /></code> and <code>&#x3C;Home /></code>) are being conditionally rendered using Vue’s v-bindings. In this case, the user sees <code>&#x3C;Work /></code> if our local state (i.e., <code>data.isWorkScreen</code>) has a value of true. Otherwise, they see, <code>&#x3C;Home /></code>.</p>\n<pre><code>&#x3C;div id=\"app\">\n  &#x3C;h1 class=\"app__header\">{{createHeader}}&#x3C;/h1>\n  &#x3C;Toggle @toggled=\"handleToggleChange\"/>\n  &#x3C;Work v-if=\"isWorkScreen\"/>\n  &#x3C;Home v-else/>\n&#x3C;/div>\n</code></pre>\n<p>In React, we would do this slightly differently. There are a number of ways we could replicate the behavior seen above, but the most straightforward way would be to use an inline JSX expression right inside of the render function.</p>\n<pre><code>&#x3C;div id=\"App\">\n  &#x3C;h1 className=\"App_header\">My Cool App&#x3C;/h1>\n  &#x3C;Toggle onClick={handleToggleChange} />\n  {isWorkScreen ? &#x3C;Work /> : &#x3C;Home />}\n&#x3C;/div>\n</code></pre>\n<h4>#2 Rendering a list</h4>\n<p>Another common thing I find myself doing when building an application is iterating through a data object and creating component instances for each item in the list. For example, this would be a good way to create every <code>&#x3C;Item /></code> in a <code>&#x3C;ToDoList /></code>.</p>\n<p>In our case, we’re creating two instances of <code>&#x3C;BusRoute /></code> in <strong>Work.vue</strong> and another two in <strong>Home.vue</strong>. In both files, we are iterating through our route information using the <code>v-for</code> binding in order to create each individual route component.</p>\n<pre><code>&#x3C;div class=\"Work\">\n  &#x3C;BusRoute\n    v-for=\"bus in buses\"\n    :key=\"`BusRoute-${bus.routeNumber}`\"\n    :routeNumber=\"bus.routeNumber\"\n    :origin=\"bus.origin\"\n    :destination=\"bus.destination\"\n    :jsonUrl=\"bus.jsonUrl\"\n  />\n&#x3C;/div>\n</code></pre>\n<p>To replicate this in React, we can use something as simple as <strong>.map</strong> to create a <code>&#x3C;BusRoute /></code> for each item in our data object. Then, we can interpolate this value into the JSX tree we’re returning.</p>\n<pre><code>const { buses } = this.state;\n\nconst busRoutes = buses.map(bus => {\n  return (\n    &#x3C;BusRoute\n      key={`BusRoute-${bus.routeNumber}`}\n      routeNumber={bus.routeNumber}\n      origin={bus.origin}\n      destination={bus.destination}\n      jsonUrl={bus.jsonUrl}\n    />\n  )\n})\n\nreturn (\n  &#x3C;div className=\"Work\">\n    {busRoutes}\n  &#x3C;/div>\n);\n</code></pre>\n<h4>#3 Rendering Children</h4>\n<p>This one probably seems straightforward, and for the most part, it is. However, coming from a React background, there was one “gotcha” when it came to working with child components.</p>\n<p>In React, this whole process is easy. You simply import the file and then use it in your renders.</p>\n<p>Vue components require an extra step. In addition to importing and using child components, Vue components must locally register their component dependencies using the Vue instance’s <code>component</code> field. This overhead is intended to help with efficient bundling, thus reducing client download sizes.</p>\n<p><strong>App.vue</strong> would be the best example of this in our bus application as it is responsible for rendering three child components at various points in its lifecycle.</p>\n<pre><code>export default {\n  name: \"App\",\n  components: {\n    Home,\n    Toggle,\n    Work\n  }\n}\n</code></pre>\n<h4>#4 Rendering children</h4>\n<p>Injecting data into your components in Vue is similar to how it was done in React before Hooks were released. Like React’s <code>componentDidMount</code>, Vue has a similar lifecycle method called <code>created</code>, which is where you would retrieve your data from an external source and ostensibly store it in local state.</p>\n<p>Here’s what these two lifecycle methods look like side by side:</p>\n<p>React:</p>\n<pre><code>componentDidMount() {\n  axios({\n    method: \"get\",\n    url: this.props.jsonUrl\n  })\n    .then(res => {\n      const { routes } = res.data;\n      this.setState({\n        departureTime: routes[0].legs[0].departure_time.text\n      });\n    })\n    .catch(err => {\n      console.log(err);\n    });\n}\n</code></pre>\n<p>Vue:</p>\n<pre><code>created: function(jsonUrl) {\n  axios({\n    method: \"get\",\n    url: this.$props.jsonUrl\n  })\n    .then(res => {\n      const { routes } = res.data;\n      this.departureTime = routes[0].legs[0].departure_time.text;\n    })\n    .catch(err => {\n      console.log(err);\n    });\n}\n</code></pre>\n<p>And let’s not forget our new friend, Hooks! If you happen to be using React 16.8 (or newer), you may have already begun writing function components that use hooks, so here’s how the above would be done in React going forward:</p>\n<pre><code>React.useEffect(() => {\n  axios({\n    method: \"get\",\n    url: props.jsonUrl\n  })\n    .then(res => {\n      const { routes } = res.data;\n\n      // setState is part of a useState hook unseen here\n      setRoute(routes[0].legs[0].departure_time.text);\n    })\n    .catch(err => {\n      console.log(err);\n    });\n}, []);\n</code></pre>\n<h4>#5 Managing component state from a parent</h4>\n<p>Earlier we used the local state (i.e., <code>data.isHomeScreen</code> in <strong>App.vue</strong>) to determine whether the user saw the Home or Work child component. But how was this value changing? Great question!</p>\n<p>If you looked at the Codesandbox, I’m sure you saw that <strong>Home</strong> and <strong>Work</strong> are not alone; they have a sibling called <strong>Toggle</strong>, which has some interesting markup we haven’t seen before.</p>\n<pre><code>&#x3C;Toggle @toggled=\"handleToggleChange\"/>\n</code></pre>\n<p>The <code>@toggled=”handleToggleChange”</code> is shorthand for another v-binding, <code>v-on</code>, which tells Vue to fire the local method <code>handleToggleChange</code>.</p>\n<pre><code>methods: {\n  handleToggleChange(newView) {\n    this.isWorkScreen = Boolean(newView === \"work\");\n  }\n}\n</code></pre>\n<p>This function simply changes the local state to flip between the <strong>Home</strong> and <strong>Work</strong> screens. But what is toggled?</p>\n<p>To answer this, we have to look inside the <strong>Toggle</strong> component. In the template, there are two <strong>ToggleButtons</strong>, both which have <code>v-on:clicked</code> bindings. These are essentially the equivalent of an <code>onClick</code> prop in React.</p>\n<pre><code>template>\n  &#x3C;div class=\"toggle\">\n    &#x3C;ToggleButton\n      @clicked=\"workClicked\"\n      :class=\"{'toggle__button': true, 'active': workActive}\"\n      text=\"Work\"\n    />\n    &#x3C;ToggleButton\n      @clicked=\"homeClicked\"\n      :class=\"{'toggle__button': true, 'active': homeActive}\"\n      text=\"Home\"\n    />\n  &#x3C;/div>\n&#x3C;/template>\n</code></pre>\n<p>Both of the callback functions toggle some local state, but the important part here is the last line of each function: <code>this.$emit(...)</code>.</p>\n<pre><code>methods: {\n  workClicked() {\n    this.workActive = true;\n    this.homeActive = false;\n    this.$emit(\"toggled\", \"work\");\n  },\n  homeClicked() {\n    this.workActive = false;\n    this.homeActive = true;\n    this.$emit(\"toggled\", \"home\");\n  }\n}\n</code></pre>\n<p>Notice the first argument, <code>toggled</code>. Essentially, this line triggers an event that <strong>App</strong> is now listening for due to the <code>@toggled</code> binding we added above.</p>\n<p>In React, we do something similar, but instead of listening for an event emitted from the child, we pass a function prop from parent to child and execute that function inside the local event listener within the child component.</p>\n<pre><code>function Child(props) {\n  return (\n    &#x3C;div>\n      &#x3C;button onClick={() => props.toggleView(\"work\")}>\n        Work\n      &#x3C;/button>\n      &#x3C;button onClick={() => props.toggleView(\"home\")}>\n        Home\n      &#x3C;/button>\n    &#x3C;/div>\n  );\n}\n\nfunction Parent() {\n  const [isWorkView, setWorkView] = React.useState(true);\n  return &#x3C;Child toggleView={setWorkView} />;\n}\n</code></pre>\n<p>Again, the result here is the same: a child component is manipulating the state of its parent.</p>\n<h3>In the end...</h3>\n<p>Building an app, even one this small, in a framework other than React was an interesting exercise for a couple reasons. Not only did I gain experience working with another framework, but I was also forced to think in a non-React way for the first time since I started using it.</p>\n<p>This, perhaps, is the most important thing to take away: it is important to explore other technologies to help us think outside the box our usual tools have put us in. Though I think I still prefer React, I don’t think I can say it’s better than Vue — just different.</p>\n<p>Here are some other thoughts I had after going through this process:</p>\n<ol>\n<li>I prefer working with React. Admittedly, this is most likely due to my past experience and familiarity with it, but I do prefer its HTML-in-JavaScript approach to Vue’s template-based one.</li>\n<li>I think Vue would be easier for developers coming from a traditional MVC background to pick up due to its similarity to templates.</li>\n<li>I would love to try building with Vue at a larger scale in order to really get a feel for it. So far, I am loving Single-File Components!</li>\n</ol>","frontmatter":{"date":"Jun. 27, 2019","title":"5 Vue tips for React developers","heroCaption":"Fotis Fotopoulos","heroLink":"https://unsplash.com/@ffstop","attachments":[{"publicURL":"/static/two-monitors-c449938f1cc28f5c3b60aa87771498fd.jpg"}]},"timeToRead":10}},"pageContext":{"slug":"posts/2019-06-27-vue-vs-react/"}}